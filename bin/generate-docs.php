#!/usr/bin/env php
<?php

/**
 * Auto-Documentation Generator for Starisian Plugins
 * Scans /src for classes, extracts PHPDoc + signatures, outputs /docs/php/*.md
 * 
 * SPDX-FileCopyrightText: 2023-2025 Starisian Technologies
 * SPDX-License-Identifier: MIT
 */

declare(strict_types=1);

$srcDir  = __DIR__ . '/../src';
$docsDir = __DIR__ . '/../docs/php-md';

if (!is_dir($docsDir)) {
    mkdir($docsDir, 0775, true);
}

$iterator = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($srcDir, RecursiveDirectoryIterator::SKIP_DOTS)
);

$classCount = 0;

foreach ($iterator as $file) {
    if ($file->getExtension() !== 'php') {
        continue;
    }

    $contents = file_get_contents($file->getRealPath());
    if (!$contents) {
        continue;
    }

    // Class detection
    if (!preg_match('/namespace\s+([^;]+);/', $contents, $ns)) {
        continue;
    }
    preg_match('/class\s+([A-Za-z0-9_]+)/', $contents, $cls);

    if (empty($cls[1])) {
        continue;
    }

    $namespace = trim($ns[1]);
    $className = trim($cls[1]);
    $fullName  = "$namespace\\$className";
    $docFile   = $docsDir . '/' . $className . '.md';

    // Extract class PHPDoc block
    preg_match('/\/\*\*((?:.|\n)*?)\*\//m', $contents, $phpDoc);

    $markdown = "# $className\n\n";
    $markdown .= "**Namespace:** `$namespace`\n\n";
    $markdown .= "**File:** `" . str_replace($srcDir, 'src', $file->getRealPath()) . "`\n\n";

    if (!empty($phpDoc[1])) {
        $cleanDoc = trim(
            preg_replace('/^\s*\*\s?/m', '', $phpDoc[1])
        );
        $markdown .= "## Description\n\n" . $cleanDoc . "\n\n";
    }

    // Extract methods
    preg_match_all(
        '/\/\*\*((?:.|\n)*?)\*\/\s+(public|protected|private)\s+(?:static\s+)?function\s+([A-Za-z0-9_]+)\s*\(/m',
        $contents,
        $methods,
        PREG_SET_ORDER
    );

    if ($methods) {
        $markdown .= "## Methods\n\n";
        foreach ($methods as $m) {
            $methodDoc = trim(preg_replace('/^\s*\*\s?/m', '', $m[1]));
            $visibility = $m[2];
            $methodName = $m[3];

            // Skip private methods unless verbose mode
            if ($visibility === 'private') {
                continue;
            }

            $markdown .= "### `$methodName()`\n\n";
            $markdown .= "**Visibility:** `$visibility`\n\n";

            if ($methodDoc) {
                $markdown .= "$methodDoc\n\n";
            } else {
                $markdown .= "_No documentation available_\n\n";
            }
        }
    }

    // Extract properties
    preg_match_all(
        '/\/\*\*((?:.|\n)*?)\*\/\s+(public|protected|private)\s+(?:static\s+)?(?:\??\w+\s+)?\$([A-Za-z0-9_]+)/m',
        $contents,
        $properties,
        PREG_SET_ORDER
    );

    if ($properties) {
        $markdown .= "## Properties\n\n";
        foreach ($properties as $prop) {
            $propDoc = trim(preg_replace('/^\s*\*\s?/m', '', $prop[1]));
            $visibility = $prop[2];
            $propName = $prop[3];

            if ($visibility === 'private') {
                continue;
            }

            $markdown .= "### `\$$propName`\n\n";
            $markdown .= "**Visibility:** `$visibility`\n\n";

            if ($propDoc) {
                $markdown .= "$propDoc\n\n";
            }
        }
    }

    $markdown .= "---\n\n";
    $markdown .= "_Generated by Starisian Documentation Generator_\n";

    file_put_contents($docFile, $markdown);
    echo "✓ Generated: $docFile\n";
    $classCount++;
}

echo "\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
echo "✅ Documentation complete: $classCount classes\n";
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n";
